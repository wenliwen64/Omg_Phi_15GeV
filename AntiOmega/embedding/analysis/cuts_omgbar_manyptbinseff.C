//xianglei's analysis macro: analyze the picoDST generated by StMcV0Maker. 

//#ifndef __CINT__
#include "stdio.h"
#include "TGraphErrors.h"
#include "TROOT.h"
#include "TMath.h"
#include "TSystem.h"
#include "TApplication.h"
#include "TFile.h"
#include "TError.h"
#include "TTree.h"
#include "TChain.h"
#include "TVector3.h"
#include "TH1.h"
#include "TH2.h"
#include "TProfile.h"
#include "TF1.h"
#include "TStyle.h"
#include "TCanvas.h"
#include "TString.h"
#include "TLeaf.h"
#include "Riostream.h"
//#include "v0dst.h"
//#include "v0dst.C"
#include <sstream>
#include <string>
#include <cstdlib>
//#include "StThreeVectorF.hh"
//#include "StPhysicalHelixD.hh"
using namespace std;
//#endif

//handy routine to convert integer to c++ string, then we can apply operators on it.
inline string stringify(int x){ ostringstream o; o << x; return o.str(); } 
//a handy routine to chain some block files listed in filelist.
TChain* ChainThem(char const* filelist, char* treename, int nlist = 0, int block = 100);

const int kGroup   = 1;
const int kCentBin = 2;
const int kPtBin = 6;
const Float_t centbd[kCentBin+1] = {20, 200, 10000};
const Float_t ptbd[kPtBin+1] = {0.7, 1.2, 1.6, 2.0, 2.4, 2.8, 3.6};

//const int kPtBin = 14;
Double_t grpbd[kGroup+1]={0.,13060000.};
//Float_t ptbd[kPtBin+1]={0.2,0.4,0.6,0.8,1.0,1.2,1.4,1.6,1.8,2.0,2.5,3.0,3.5,4.0,5.0,6.0,8.0};
//
//Float_t  ptbd[kPtBin+1]={0.2,0.4,0.6,0.8,1.0,1.2,1.4,1.6,1.8,2.0,2.5,3.0,3.5,4.0,4.7};

Double_t getWeight(Int_t cent, Float_t pt, string option);

int cuts_omgbar_manyptbinseff(int nlist, int block,  string option){
    //firstly use the TTree::MakeClass to generate a handy wrapper class.
    //modify it (the array size) and load it here
    //#ifdef __CINT__
    //   gROOT->LoadMacro("v0dst.C+");
    //#endif

    TChain* chain = new TChain("McXiPicoDst");
    std::string filelist;
    if(option == "flat"){
	chain -> Add("./mc_fp_omgbar_15GeV.picodst.root");
    }
    else if(option == "exp"){
	chain -> Add("./mc_exp_omgbar_15GeV.picodst.root");
    }
    else{
	std::cout<<"BAD OPTION!!"<<std::endl;
    }

    if(!chain){ 
	cout<<"ERROR: no files are added to the chain!"<<endl; return -1; 
    }

    //bound them together
    //v0dst dst(t);

    //histograms
    //TString Dir("");
    string Dir = "./";
    //TString Name("mcla_fp");
    string Name;
    if(option == "flat"){
	Name = "mcomgbar_fp";
    }
    else if(option == "exp"){
	Name = "mcomgbar_exp";
    }
    else{
	std::cerr<<"BAD OPTION"<<std::endl;
	return -1;
    }
    string filename = Dir+Name+".manyeff.histo.root"; 
    TFile ohm(filename.c_str(),"recreate");

    Float_t pdgV0Mass = 1.115683;
    Float_t pdgXiMass = 1.67245;
    Float_t masswidth = 0.07+0.01;

    int totCount=0;
    int nCount=0;

    //QA histograms about event-wise information
    TH1F * hmNRefMult = new TH1F("hmNRefMult","Number of reference multiplicity",4000,0,1000);
    TH1F * hmVertexZ  = new TH1F("hmVertexZ","Vertex Z", 120,-30,30);
    TH1F * hmVertexR  = new TH1F("hmVertexR","Vertex R", 200,-10,10);
    TH1F * hmNMcXi    = new TH1F("hmNMcXi","Number of MC Xi",100,0,100);
    TH1F * hmNRcXi    = new TH1F("hmNRcXi","Number of RC Xi",100,0,100);
    TH2F * hmNMcRcV0  = new TH2F("hmNMcRcXi","Number of Mc and Rc Xi",100,0,100,50,0,50);

    //QA histograms needed to compare to real data 
    TH1F * hmDau1nHits[kCentBin][kPtBin];
    TH1F * hmDau1Pt[kCentBin][kPtBin];
    TH1F * hmDau2nHits[kCentBin][kPtBin];
    TH1F * hmDau2Pt[kCentBin][kPtBin];

    TH1F * hmDau1Dca[kCentBin][kPtBin];
    TH1F * hmDau2Dca[kCentBin][kPtBin];
    TH1F * hmDca1to2[kCentBin][kPtBin];
    TH1F * hmV0Dca[kCentBin][kPtBin];
    TH1F * hmV0DecLen[kCentBin][kPtBin];
    TH1F * hmV0InvMass[kCentBin][kPtBin];
    TH1F * hmV0Colinear[kCentBin][kPtBin];

    TH1F * hmBachDca[kCentBin][kPtBin];
    TH1F * hmBachnHits[kCentBin][kPtBin];
    TH1F * hmBachPt[kCentBin][kPtBin];
    TH1F * hmDcav0tobach[kCentBin][kPtBin];
    TH1F * hmXiDca[kCentBin][kPtBin];
    TH1F * hmXiDecLen[kCentBin][kPtBin];
    TH1F * hmDecLenDiff[kCentBin][kPtBin]; 
    TH1F * hmXiInvMass[kCentBin][kPtBin];
    TH1F * hmXiColinear[kCentBin][kPtBin];
    TH1F * hmSinth[kCentBin][kPtBin];

    //QA histograms about MC V0
    TH1F* hmMcXiPt[kCentBin];
    TH1F* hmMcXiRap[kCentBin];
    TH1F* hmRcXiPt[kCentBin];
    TH1F* hmRcXiRap[kCentBin];

    //QA histograms about RC V0
    //TH1F * hmRcV0Pt_010   = new TH1F("hmRcV0Pt","Pt of RC V0", 100, -5, 5);
    //TH1F * hmRcV0Rap_010   = new TH1F("hmRcV0Rap","Rapidity of RC V0", 100, -1, 1);
    //TH1F * hmRcV0Pt_1060   = new TH1F("hmMcV0Pt","Pt of RC V0", 100, 0, 10);
    //TH1F * hmRcV0Rap_1060   = new TH1F("hmMcV0Rap","Rapidity of RC V0", 100, -2, 2);
    //TH2F * hmTwoTracknHits = new TH2F("hmTwoTracknHits","nHits of Two Tracks", 50,-0.5,49.5,50,-0.5,49.5);

    //TH2I * hmSumMcV0 = new TH2I("hmSumMcV0", "MC V0 counts in different cent and pt bin", kCentBin,0,kCentBin,kPtBin,0,kPtBin);
    //TH2I * hmSumRcV0 = new TH2I("hmSumRcV0", "RC V0 counts in different cent and pt bin", kCentBin,0,kCentBin,kPtBin,0,kPtBin);

    //Double_t wMcCount[kCentBin][kPtBin];
    //Double_t wRcCount[kCentBin][kPtBin];
    //Double_t wRcOutCount[kCentBin][kPtBin];
    //Double_t w2McCount[kCentBin][kPtBin];
    //Double_t w2RcCount[kCentBin][kPtBin];
    //Double_t w2RcOutCount[kCentBin][kPtBin];

    //TH1F * hmIM[kCentBin][kPtBin];
    //TH1F * hmIMCent[kCentBin];
    //TH1F * hmTrack1[kCentBin][kPtBin];//new
    //TH1F * hmTrack2[kCentBin][kPtBin];//new

    //TH1F* hmPtRC[kCentBin];
    //TH1F* hmPtMC[kCentBin];

    //for(Int_t iIM=0; iIM<kCentBin; iIM++){
    //TString hName("hmInvMass");
    //string hName = "hmInvMass"; 
    //TString hTitle("Invariant mass for ");
    //string hTitle = "Invariant mass for";
    //hName = hName + "Cent" + stringify(iIM);
    //hTitle = hTitle + "centrality bin " + stringify(iIM);
    //hmIMCent[iIM] = new TH1F(hName.c_str(), hTitle.c_str(), 200, pdgmass-masswidth, pdgmass+masswidth);

    //==========>Initialize Histograms<============
    for(Int_t iCent = 0; iCent < kCentBin; iCent++){
	TString hMcXiPtName;
	TString hMcXiPtTitle;
	TString hRcXiPtName; 
	TString hRcXiPtTitle;

	hMcXiPtName.Form("hmcxiptcen%d", iCent);
	hMcXiPtTitle.Form("mcxiptcen%d", iCent);
	hRcXiPtName.Form("hrcxiptcen%d", iCent);
	hRcXiPtTitle.Form("rcxiptcen%d", iCent);
	hmMcXiPt[iCent] = new TH1F(hMcXiPtName.Data(), hMcXiPtTitle.Data(), 100, 0, 4.5);
	hmRcXiPt[iCent] = new TH1F(hRcXiPtName.Data(), hRcXiPtTitle.Data(), 100, 0, 4.5);
	//hmMcXiPt[iCent] = new TH1F(hMcXiPtName.Data(), hMcXiPtTitle.Data(), kPtBin, ptbd);
	//hmRcXiPt[iCent] = new TH1F(hRcXiPtName.Data(), hRcXiPtTitle.Data(), kPtBin, ptbd);

	cout<<"happy"<<endl;
	for(Int_t iPt = 0; iPt < kPtBin; iPt++){
	    TString hDau1nHitsName;
	    TString hDau2nHitsName;
	    TString hBachnHitsName;
	    TString hDau1PtName;
	    TString hDau2PtName;
            TString hBachPtName;
	    TString hDau1DcaName; 
	    TString hDau2DcaName; 
	    TString hDca1to2Name; 
	    TString hV0DcaName; 
	    TString hV0DecLenName;
	    TString hV0InvMassName;
	    TString hV0ColinearName;

	    TString hBachDcaName; 
	    TString hDcav0tobachName;
	    TString hXiDcaName;
	    TString hXiDecLenName;
	    TString hDecLenDiffName;
	    TString hXiInvMassName;
	    TString hXiColinearName;
            TString hSinthName;

	    TString hDau1nHitsTitle;
	    TString hDau2nHitsTitle;
	    TString hBachnHitsTitle;
	    TString hDau1PtTitle;
	    TString hDau2PtTitle;
	    TString hBachPtTitle;
	    TString hDau1DcaTitle; 
	    TString hDau2DcaTitle; 
	    TString hDca1to2Title; 
	    TString hV0DcaTitle; 
	    TString hV0DecLenTitle;
	    TString hV0InvMassTitle;
	    TString hV0ColinearTitle;

	    TString hBachDcaTitle; 
	    TString hDcav0tobachTitle;
	    TString hXiDcaTitle;
	    TString hXiDecLenTitle;
	    TString hDecLenDiffTitle;
	    TString hXiInvMassTitle;
            TString hXiColinearTitle;
            TString hSinthTitle;
	    hDau1nHitsName.Form("hmDau1nHits_cen%dpt%d", iCent, iPt);
	    hDau2nHitsName.Form("hmDau2nHits_cen%dpt%d", iCent, iPt);
	    hBachnHitsName.Form("hmBachnHits_cen%dpt%d", iCent, iPt);
	    hDau1PtName.Form("hmDau1Pt_cen%dpt%d", iCent, iPt);
	    hDau2PtName.Form("hmDau2Pt_cen%dpt%d", iCent, iPt);
	    hBachPtName.Form("hmBachPt_cen%dpt%d", iCent, iPt);
	    hDau1DcaName.Form("hmDau1Dca_cen%dpt%d", iCent, iPt);
	    hDau2DcaName.Form("hmDau2Dca_cen%dpt%d", iCent, iPt);
	    hDca1to2Name.Form("hmDca1to2_cen%dpt%d", iCent, iPt);
	    hV0DcaName.Form("hmV0Dca_cen%dpt%d", iCent, iPt);
	    hV0DecLenName.Form("hmV0DecLen_cen%dpt%d", iCent, iPt);
	    hV0InvMassName.Form("hmV0Invmass_cen%dpt%d", iCent, iPt);
	    hV0ColinearName.Form("hmV0Colinear_cen%dpt%d", iCent, iPt);

	    hBachDcaName.Form("hmBachDca_cen%dpt%d", iCent, iPt);
	    hDcav0tobachName.Form("hmDcav0tobach_cen%dpt%d", iCent, iPt);
	    hXiDcaName.Form("hmXiDca_cen%dpt%d", iCent, iPt);
	    hXiDecLenName.Form("hmXiDecLen_cen%dpt%d", iCent, iPt);
	    hDecLenDiffName.Form("hmDecLenDiff_cen%dpt%d", iCent, iPt);
	    hXiInvMassName.Form("hmXiInvMass_cen%dpt%d", iCent, iPt);
	    hXiColinearName.Form("hmXiColinear_cen%dpt%d", iCent, iPt);
	    hSinthName.Form("hmXisinth_cen%dpt%d", iCent, iPt);
	    cout<<"happy"<<iPt<<endl;

	    hDau1nHitsTitle.Form("Dau1_nHits centrality bin%d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);
	    hDau2nHitsTitle.Form("Dau2_nHits centrality bin%d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);
	    hBachnHitsTitle.Form("Bach_nHits centrality bin%d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);
	    hDau1PtTitle.Form("Dau1_Pt ceentrality bin %d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);
	    hDau2PtTitle.Form("Dau2_Pt centrality bin %d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);
	    hBachPtTitle.Form("Bach_Pt centrality bin %d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);
	    hDau1DcaTitle.Form("Dau1_Dca centrality bin %d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);
	    hDau2DcaTitle.Form("Dau2_Dca centrality bin %d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);
	    hDca1to2Title.Form("Dca1to2 centrality bin %d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);
	    hV0DcaTitle.Form("V0_Dca centrality bin %d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);
	    hV0DecLenTitle.Form("V0_DecLen centrality bin %d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);
	    hV0InvMassTitle.Form("V0_Invmass centrality bin %d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);
	    hV0ColinearTitle.Form("V0_Colinear centrality bin  %d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);

	    hBachDcaTitle.Form("Bach_Dca centrality bin %d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);
	    hDcav0tobachTitle.Form("Dca_v0tobach centrality bin %d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);
	    hXiDcaTitle.Form("Xi_Dca centrality bin %d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);
	    hXiDecLenTitle.Form("Xi_DecLen centrality bin %d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);
	    hDecLenDiffTitle.Form("DecLenDiff centrality bin %d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);
	    hXiInvMassTitle.Form("Xi_InvMass centrality bin %d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]);
	    hXiColinearTitle.Form("Xi_Colinear centrality bin %d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]); 
	    hSinthTitle.Form("Xi_sinth centrality bin  %d(%3.1f < pt < %3.1f)", iCent, ptbd[iPt], ptbd[iPt+1]); 

	    hmDau1nHits[iCent][iPt] = new TH1F(hDau1nHitsName.Data(), hDau1nHitsTitle.Data(), 50, -0.5, 49.5);//new
	    hmDau2nHits[iCent][iPt] = new TH1F(hDau2nHitsName.Data(), hDau2nHitsTitle.Data(), 50, -0.5, 49.5);//new
	    hmBachnHits[iCent][iPt] = new TH1F(hBachnHitsName.Data(), hBachnHitsTitle.Data(), 50, -0.5, 49.5);//new
	    hmDau1Pt[iCent][iPt] = new TH1F(hDau1PtName.Data(), hDau1PtTitle.Data(), 100, 0, 10);
	    hmDau2Pt[iCent][iPt] = new TH1F(hDau2PtName.Data(), hDau2PtTitle.Data(), 100, 0, 10);
	    hmBachPt[iCent][iPt] = new TH1F(hBachPtName.Data(), hBachPtTitle.Data(), 100, 0, 10);
	    hmDau1Dca[iCent][iPt] = new TH1F(hDau1DcaName.Data(), hDau1DcaTitle.Data(), 100, 0, 10.0);
	    hmDau2Dca[iCent][iPt] = new TH1F(hDau2DcaName.Data(), hDau2DcaTitle.Data(), 100, 0, 10.0);
	    hmDca1to2[iCent][iPt] = new TH1F(hDca1to2Name.Data(), hDca1to2Title.Data(), 200, 0, 1.2);
	    hmV0Dca[iCent][iPt] = new TH1F(hV0DcaName.Data(), hV0DcaTitle.Data(), 200, 0, 5.5); 
	    hmV0DecLen[iCent][iPt] = new TH1F(hV0DecLenName.Data(), hV0DecLenTitle.Data(), 200, 0, 100); 
	    hmV0InvMass[iCent][iPt] = new TH1F(hV0InvMassName.Data(), hV0InvMassTitle.Data(), 300, pdgV0Mass-masswidth, pdgV0Mass+masswidth);
	    hmV0Colinear[iCent][iPt] = new TH1F(hV0ColinearName.Data(), hV0ColinearTitle.Data(), 100, 0, 1);

	    cout<<"happy mid"<<iPt<<endl;
	    hmBachDca[iCent][iPt] = new TH1F(hBachDcaName.Data(), hBachDcaTitle.Data(), 200, 0, 25);
	    hmDcav0tobach[iCent][iPt] = new TH1F(hDcav0tobachName.Data(), hDcav0tobachTitle.Data(), 200, 0, 2);
	    hmXiDca[iCent][iPt] = new TH1F(hXiDcaName.Data(), hXiDcaTitle.Data(), 100, 0, 1.2);
	    hmXiDecLen[iCent][iPt] = new TH1F(hXiDecLenName.Data(), hXiDecLenTitle.Data(), 200, 0, 80);
	    hmDecLenDiff[iCent][iPt] = new TH1F(hDecLenDiffName.Data(), hDecLenDiffTitle.Data(), 200, 0, 80);
	    hmXiInvMass[iCent][iPt] = new TH1F(hXiInvMassName.Data(), hXiInvMassTitle.Data(), 300, pdgXiMass - masswidth, pdgXiMass + masswidth);
	    hmXiColinear[iCent][iPt] = new TH1F(hXiColinearName.Data(), hXiColinearTitle.Data(), 100, 0, 1);
	    hmSinth[iCent][iPt] = new TH1F(hSinthName.Data(), hSinthTitle.Data(), 200, 0, 0.3);
	}
    }

    cout<<"happyII"<<endl;
    //string nmPtRC = "rcpt_la";
    //nmPtRC = nmPtRC + Form("%d", iIM);
    //string titlePtRC = "rcpt_la";
    //titlePtRC = titlePtRC + Form("%d", iIM);

    //string nmPtMC = "mcpt_la";
    //nmPtMC = nmPtMC + Form("%d", iIM);
    //string titlePtMC = "mcpt_la";
    //titlePtMC = titlePtMC + Form("%d", iIM);

    //hmPtRC[iIM] = new TH1F(nmPtRC.c_str(), titlePtRC.c_str(), kPtBin, ptbd);
    //hmPtRC[iIM] = new TH1F(nmPtRC.c_str(), titlePtRC.c_str(), 50, 0, 2.5);
    //hmPtMC[iIM] = new TH1F(nmPtMC.c_str(), titlePtMC.c_str(), kPtBin, ptbd);
    //hmPtMC[iIM] = new TH1F(nmPtMC.c_str(), titlePtMC.c_str(), 50, 0, 2.5);
    //}

    //histogram for cent bin and pt bin
    //TH1D * hmGroup = new TH1D("hmGroup","Run Group finder",kGroup,grpbd);
    //TH1F * hmCent[kGroup];
    /*
       for(Int_t i=0;i<kGroup;i++){
    //TString hName("hmCent");
    string hName = "hmCent";
    hName = hName + stringify(i);
    //TString hTitle("Centrality bin finder for group ");
    string hTitle = "Centrality bin finder for group ";
    hTitle = hTitle + stringify(i);
    //hmCent[i] = new TH1F(hName.c_str(),hTitle.c_str(),kCentBin,centbd[i]);
    }
    */
    TH1F* hmPt = new TH1F("hmPt", "Pt bin finder", kPtBin, ptbd);
    TH1F* hmCent = new TH1F("hmCent", "cen bin finder", kCentBin, centbd);
    cout<<"so far so good"<<endl;

    int mcidvec[200];

    //event loop (copy from wrapper class' Loop method
    Long64_t nentries = chain->GetEntries();
    Long64_t nbytes = 0, nb = 0;
    for(Long64_t jentry = 0; jentry < nentries; jentry++) {
	if(jentry%1000 == 0) std::cout << "Processing entry == " << jentry << " == out of " << nentries << ".\n";
	chain->GetEntry(jentry);
	TLeaf* leaf_nrefmult = chain->GetLeaf("nrefmult");
	TLeaf* leaf_primvertexZ = chain->GetLeaf("primvertexZ");
	TLeaf* leaf_primvertexX = chain->GetLeaf("primvertexX");
	TLeaf* leaf_primvertexY = chain->GetLeaf("primvertexY");
       
	TLeaf* leaf_nmcxi = chain->GetLeaf("nmcxi");
	TLeaf* leaf_nxi = chain->GetLeaf("nxi");
	TLeaf* leaf_mcxiid = chain->GetLeaf("mcxiid");
	TLeaf* leaf_mcxirapidity = chain->GetLeaf("mcxirapidity");
	TLeaf* leaf_mcxipt = chain->GetLeaf("mcxipt");
	TLeaf* leaf_v0mass = chain->GetLeaf("v0mass");
	TLeaf* leaf_v0declen = chain->GetLeaf("v0declen");
	TLeaf* leaf_v0dca = chain->GetLeaf("v0dca");
        TLeaf* leaf_v0x = chain->GetLeaf("v0x");
        TLeaf* leaf_v0y = chain->GetLeaf("v0y");
        TLeaf* leaf_v0z = chain->GetLeaf("v0z");
        TLeaf* leaf_v0px = chain->GetLeaf("v0px");
        TLeaf* leaf_v0py = chain->GetLeaf("v0py");
        TLeaf* leaf_v0pz = chain->GetLeaf("v0pz");
	TLeaf* leaf_dau1id = chain->GetLeaf("dau1id");
	TLeaf* leaf_dau1dca = chain->GetLeaf("dau1dca");
	TLeaf* leaf_dau1nhits = chain->GetLeaf("dau1nhits");
	TLeaf* leaf_dau1pt = chain->GetLeaf("dau1pt");
	TLeaf* leaf_dau2id = chain->GetLeaf("dau2id");
	TLeaf* leaf_dau2dca = chain->GetLeaf("dau2dca");
	TLeaf* leaf_dau2nhits = chain->GetLeaf("dau2nhits");
	TLeaf* leaf_dau2pt = chain->GetLeaf("dau2pt");
	TLeaf* leaf_dca1to2 = chain->GetLeaf("dca1to2");
	TLeaf* leaf_bachid = chain->GetLeaf("bachid");
	TLeaf* leaf_bachpt = chain->GetLeaf("bachpt");
	TLeaf* leaf_bachnhits = chain->GetLeaf("bachnhits");
	TLeaf* leaf_bachdca = chain->GetLeaf("bachdca");
	TLeaf* leaf_dcav0tobach = chain->GetLeaf("dcav0tobach");
        TLeaf* leaf_xipt = chain -> GetLeaf("xipt");
        TLeaf* leaf_xix = chain -> GetLeaf("xix");
        TLeaf* leaf_xiy = chain -> GetLeaf("xiy");
        TLeaf* leaf_xiz = chain -> GetLeaf("xiz");
        TLeaf* leaf_xipx = chain -> GetLeaf("xipx");
        TLeaf* leaf_xipy = chain -> GetLeaf("xipy");
        TLeaf* leaf_xipz = chain -> GetLeaf("xipz");
	TLeaf* leaf_xidca = chain->GetLeaf("xidca");
	TLeaf* leaf_xideclen = chain->GetLeaf("xideclen");
	TLeaf* leaf_xirapidity = chain->GetLeaf("xirapidity");
        TLeaf* leaf_ximcid = chain->GetLeaf("ximcid");
        TLeaf* leaf_ximass = chain->GetLeaf("ximass");
        TLeaf* leaf_xisinth = chain->GetLeaf("xisinth");

	Int_t nrefmult = leaf_nrefmult->GetValue(0);
	Float_t primvertexZ = leaf_primvertexZ->GetValue(0);
	Float_t primvertexX = leaf_primvertexX->GetValue(0);
	Float_t primvertexY = leaf_primvertexY->GetValue(0);
	Int_t nmcxi = leaf_nmcxi->GetValue(0);
	Int_t nxi = leaf_nxi->GetValue(0);

	if(fabs(primvertexZ) > 70.0) continue;
	Float_t vr = sqrt(primvertexX*primvertexX + (primvertexY+0.89)*(primvertexY+0.89));
	if(vr >= 1.0) continue; 

	Int_t centbin = hmCent->FindBin(nrefmult) - 1.;//TODO:
	for(Int_t i = 0; i < nmcxi; i++){
	    Int_t mcxiid = leaf_mcxiid->GetValue(i);
	    Float_t mcxirapidity = leaf_mcxirapidity->GetValue(i);
	    Float_t mcxipt = leaf_mcxipt->GetValue(i);
	    mcidvec[i] = mcxiid;
	    if(fabs(mcxirapidity) > 0.5) continue;//the origin code
	    Int_t ptbin = hmPt->FindBin(mcxipt) - 1.;
	    if(ptbin == kPtBin) ptbin = -1;//Underflow and Overflow
            if(centbin < 0) continue;
	    //if( ptbin < 0) continue;
	    Double_t wgt = getWeight(centbin, mcxipt, option);
	    //wMcCount[centbin][ptbin] += wgt; 
	    //w2McCount[centbin][ptbin] += wgt*wgt; 
	    hmMcXiPt[centbin]->Fill(mcxipt, 1);
	}

	for(Int_t i = 0; i < nxi; i++){
	    Int_t dau1nhits = leaf_dau1nhits->GetValue(i);
	    Int_t dau2nhits = leaf_dau2nhits->GetValue(i);
	    Int_t bachnhits = leaf_bachnhits->GetValue(i);
	    Float_t dau1pt = leaf_dau1pt->GetValue(i);
	    Float_t dau2pt = leaf_dau2pt->GetValue(i);
	    Float_t bachpt = leaf_bachpt->GetValue(i);
	    Float_t dau1dca = leaf_dau1dca->GetValue(i);
	    Float_t dau2dca = leaf_dau2dca->GetValue(i);
	    Float_t dca1to2 = leaf_dca1to2->GetValue(i);
            Float_t v0x = leaf_v0x->GetValue(i);
            Float_t v0y = leaf_v0y->GetValue(i);
            Float_t v0z = leaf_v0z->GetValue(i);
            Float_t v0px = leaf_v0px->GetValue(i);
            Float_t v0py = leaf_v0py->GetValue(i);
            Float_t v0pz = leaf_v0pz->GetValue(i);
	    Float_t v0dca = leaf_v0dca->GetValue(i);
	    Float_t v0declen = leaf_v0declen->GetValue(i);
	    Float_t v0mass= leaf_v0mass->GetValue(i); 
	    Float_t bachdca = leaf_bachdca->GetValue(i);
	    Float_t dcav0tobach = leaf_dcav0tobach->GetValue(i);
            Float_t xix = leaf_xix->GetValue(i);
            Float_t xiy = leaf_xiy->GetValue(i);
            Float_t xiz = leaf_xiz->GetValue(i);
            Float_t xipx = leaf_xipx->GetValue(i);
            Float_t xipy = leaf_xipy->GetValue(i);
            Float_t xipz = leaf_xipz->GetValue(i);
            Float_t xipt = leaf_xipt->GetValue(i);
	    Float_t xidca = leaf_xidca->GetValue(i);
	    Float_t xideclen = leaf_xideclen->GetValue(i);
	    Float_t xirapidity = leaf_xirapidity->GetValue(i); 
	    Int_t ximcid = leaf_ximcid->GetValue(i);
            Float_t ximass = leaf_ximass->GetValue(i);
            Float_t xisinth = leaf_xisinth->GetValue(i);

	    if(dau1dca < 0.6) continue;
	    if(dau2dca < 2.0) continue;
	    if(dca1to2 > 0.7) continue;
	    if(v0dca < 0.4) continue;
	    if(v0declen < 5.) continue;
	    //if(fabs(dst.v0eta[i]) > 1.) continue;
	    if(abs(v0mass-1.115683) > 0.006) continue;

	    if(bachdca < 1.0) continue;
	    if(dcav0tobach > 0.7) continue;
	    if(xidca > 0.4) continue;
	    if(xideclen < 3.0) continue;
	    if(xideclen > v0declen) continue;
	    if(fabs(xirapidity) > 0.5) continue;

/*
            TVector3 pv(primvertexX, primvertexY, primvertexZ); 
            TVector3 xv0(v0x, v0y, v0z); 
            TVector3 pv0(v0px, v0py, v0pz);
            TVector3 xxi(xix, xiy, xiz);
            TVector3 pxi(xipx, xipy, xipz);
 
            TVector3 v0displacement = xv0 - pv; 
            TVector3 xidisplacement = xxi - pv;
            //TVector3 xircrossp = xidisplacement.Cross(pxi);

            Float_t v0rdotp = v0displacement.Dot(pv0);
            Float_t xirdotp = xidisplacement.Dot(pxi);
   
            //Float_t sinth = xircrossp.Mag() / xidisplacement.Mag() / pxi.Mag();

            if(v0rdotp < 0) continue;
            if(xirdotp < 0) continue;
*/
            if(xisinth > 0.15) continue;
	    //find the MC v0 index according to their ids
	    int ind = -1;
	    for(int ik = 0; ik < nmcxi; ik++){
		if(mcidvec[ik]==ximcid){
		    ind = ik; 
		    break;
		}
	    }

	    //if(centbin>=0)  hmIMCent[centbin]->Fill(dst.v0mass[i]);
            if(centbin < 0) continue;
            if(xipt > 6.0) continue;//6.0 is the mc upperbound, otherwise the eff would be inf.

	    Int_t ptbin = hmPt->FindBin(xipt) - 1;
	    if(ptbin >= kPtBin) ptbin = -1;
	    if(ptbin < 0) continue;
            if(fabs(ximass - pdgXiMass) > 0.007) continue;
	    if(ind > -1){
                Double_t wgt = getWeight(centbin, xipt, option); 
		hmRcXiPt[centbin]->Fill(xipt, 1);
		hmDau1nHits[centbin][ptbin]->Fill(dau1nhits);
		hmDau2nHits[centbin][ptbin]->Fill(dau2nhits);
		hmBachnHits[centbin][ptbin]->Fill(bachnhits);
		hmDau1Pt[centbin][ptbin]->Fill(dau1pt);
		hmDau2Pt[centbin][ptbin]->Fill(dau2pt);
		hmBachPt[centbin][ptbin]->Fill(bachpt);
		hmDau1Dca[centbin][ptbin]->Fill(dau1dca);
		hmDau2Dca[centbin][ptbin]->Fill(dau2dca);
		hmDca1to2[centbin][ptbin]->Fill(dca1to2); 
		hmV0DecLen[centbin][ptbin]->Fill(v0declen);
		hmV0Dca[centbin][ptbin]->Fill(v0dca);
		hmV0InvMass[centbin][ptbin]->Fill(v0mass);
                //hmV0Colinear[centbin][ptbin]->Fill(v0rdotp);
		hmBachDca[centbin][ptbin]->Fill(bachdca);
		hmDcav0tobach[centbin][ptbin]->Fill(dcav0tobach);
		hmXiDca[centbin][ptbin]->Fill(xidca);
		hmXiDecLen[centbin][ptbin]->Fill(xideclen);
		hmXiInvMass[centbin][ptbin]->Fill(ximass);
                //hmXiColinear[centbin][ptbin]->Fill(xirdotp);
                hmDecLenDiff[centbin][ptbin]->Fill(v0declen - xideclen);
                hmSinth[centbin][ptbin]->Fill(xisinth);
	    }
	}
    }

    //==== To Get The Eff. Plots&Data ====
    TH1F* hmEffXiPt[2];
    for(int i = 0; i < kCentBin; i++){
	hmRcXiPt[i] -> Sumw2();
	hmMcXiPt[i] -> Sumw2();

	hmEffXiPt[i] = (TH1F*)hmRcXiPt[i] -> Clone();
        hmEffXiPt[i]->Sumw2();
        TString newName;
        newName.Form("effxiptcent%d", i);
        hmEffXiPt[i]->SetName(newName.Data());
        hmEffXiPt[i]->Divide(hmMcXiPt[i]);
	//hmRcXiPt[i]->Write();
    }

    string ofile;
    string ofile_scale;
    if(option == "flat"){
	ofile = "./eff_omgbar_fp.dat";
	ofile_scale = "./eff_omgbar_fp_scale.dat";
    }
    else if(option == "exp"){
	ofile = "./eff_omgbar_exp.dat";
	ofile_scale = "./eff_omgbar_exp_scale.dat";
    }
    else{
	return -1;
    }

    ofstream oweight(ofile.c_str());
    ofstream oweight_scale(ofile_scale.c_str());
   
    TProfile* eff010 = new TProfile("ep010", "ep010", kPtBin, ptbd);
    TProfile* eff1060 = new TProfile("ep1060", "ep1060", kPtBin, ptbd);
    eff010->BuildOptions(0, 0, "s");
    eff1060->BuildOptions(0, 0, "s");
   
    for(int i = 0; i < 100; i++){
        double effpt = hmEffXiPt[1]->GetBinCenter(i+1);
        double tmpeff = hmEffXiPt[1]->GetBinContent(i+1);
        double weight010 = getWeight(1, effpt, option);
	eff010->Fill(effpt, tmpeff, weight010);

        effpt = hmEffXiPt[0]->GetBinCenter(i+1);
        tmpeff = hmEffXiPt[0]->GetBinContent(i+1);
        double weight1060 = getWeight(0, effpt, option);
	eff1060->Fill(effpt, tmpeff, weight1060);
    }

    for(int j = 0; j < kPtBin; j++){
	float eff = eff1060->GetBinContent(j+1);
	float err = eff1060->GetBinError(j+1);
	if(eff != 0)
	    oweight << 0 << " " << j+1 << " " << eff << " " << err << std::endl; 
    }

    for(int j = 0; j < kPtBin; j++){
	float eff = eff010->GetBinContent(j+1);
	float err = eff010->GetBinError(j+1);
	if(eff != 0)
	    oweight << 1 << " " << j+1 << " " << eff << " " << err << std::endl;
    }

    //==== Plot Eff. ====
    float effx[6];
    float effy[2][6];
    float effyerr[2][6];
    for(int i = 0; i < kPtBin; i++){
        effx[i] = eff1060->GetBinCenter(i+1);
        effy[0][i] = eff1060->GetBinContent(i+1);
        effyerr[0][i] = eff1060->GetBinError(i+1);
        effy[1][i] = eff010->GetBinContent(i+1);
        effyerr[1][i] = eff010->GetBinError(i+1);
    }
 
    TCanvas* ceff = new TCanvas("ceff"); 
    ceff->SetLogy();
    ceff->SetTicks(1, 1);
    TGraphErrors* eff_gre = new TGraphErrors(kPtBin, effx, effy[0], 0, effyerr[0]); 
    eff_gre->SetTitle("#Omega^- Efficiency, Au+Au 14.6GeV"); 
    eff_gre->SetMarkerStyle(20);
    eff_gre->SetMarkerSize(1.35);
    eff_gre->SetMarkerColor(2);
    eff_gre->Draw("P");
    ceff->SaveAs("../plots/eff_omgbar060.eps");
	//Depending on previous result , begin with 2 and stop at 9 
/*
	for(int j = 0; j < kPtBin; j++){
	    float eff = hmEffXiPt[i]->GetBinContent(j+1);
	    float err = hmEffXiPt[i]->GetBinError(j+1);
	    if(eff != 0)
		oweight_scale << i << " " << j+1 << " " << eff << " " << err <<std::endl; 
	}
*/
    cout<<"Counts = "<<nCount<<endl;
    cout<<"Total Counts = "<<totCount<<endl;

    oweight.close();
    oweight_scale.close();

    ohm.Write();	//save all booked histograms
    ohm.Close();
    delete chain;
    return 0;
}

Double_t getWeight(Int_t cent, Float_t pt, string option){
    Double_t wgt;
    //parameterize levy function to supply the weight

    static TF1 levy("levy","[0]*pow(1+(sqrt(x*x+1.67245*1.67245)-1.67245)/([1]*[2]),-[1])*([1]-1)*([1]-2)/(2*3.14159265*[1]*[2]*([1]*[2]+1.67245*([1]-2)))",0.,8.);
    static TF1 levy_pt("levypt","x*[0]*pow(1+(sqrt(x*x+1.67245*1.67245)-1.67245)/([1]*[2]),-[1])*([1]-1)*([1]-2)/(2*3.14159265*[1]*[2]*([1]*[2]+1.67245*([1]-2)))",0.,8.);
    ifstream ipara("../../plot_scripts/levy_par_antiomg.dat");
    Double_t yield[kCentBin] = {0.};
    Double_t pwindex[kCentBin] = {0.};
    Double_t slope[kCentBin] = {0.};
    double dummy;
    for(int i = 0;i<kCentBin;i++)
    {
	ipara>>dummy>>yield[i]>>pwindex[i]>>slope[i];
	//yield[i]=yield[i]*pow(10,6-i);
    }
    ipara.close();
    //levy.SetParameters(yield[cent],pwindex[cent],slope[cent]);
    levy_pt.SetParameters(yield[cent],pwindex[cent],slope[cent]);

    //wgt = levy.Eval(pt);
    wgt = levy_pt.Eval(pt);
    /*
       static TF1 dexp("dexp","x*[0]/2.0/3.141592654*([1]/[2]/(1.115683+[2])*exp(-(sqrt(x*x+1.115683*1.115683)-1.115683)/[2])+(1.-[1])/[3]/(1.115683+[3])*exp(-(sqrt(x*x+1.115683*1.115683)-1.115683)/[3]))",0,10.0);
       dexp.SetParameters(1.10655e+02,5.10130e-02,5.98316e-01,2.83653e-01);
       wgt = dexp.Eval(pt);
       */

    //return wgt;
    //float wgt = 0;
    if(option == "flat"){
	wgt = wgt;
    }
    else if(option == "exp"){
	wgt = wgt*exp(pt/0.35)/pt; 
    }
    else{
	std::cout<<"BAD OPTION!!!"<<std::endl;
	return -1;
    }
    return wgt;
}

TChain* ChainThem(char const* filelist, char* treename, int nlist, int block){

    TChain *globChain = new TChain(treename);

    cout << ">>> Load Chain from file: " << filelist << endl;
    ifstream fList(filelist);
    if (!fList)
    {
	cout << "!!! Can't open file " << filelist << endl;
	return NULL;
    }

    int Ncount = 0;
    int Nfiles = 0;
    char lineFromFile[255];
    while(fList.getline(lineFromFile, 250))
    {
	Ncount++;
	if(Ncount<=nlist*block)continue;
	if(Ncount>(nlist+1)*block)break;
	if(globChain->Add(lineFromFile,0)){
	    cout << ">> File '" << lineFromFile << "' has been loaded" << endl;
	    Nfiles ++;
	}
	else
	    cout << ">> Can't load file '" << lineFromFile << "'" << endl;
    }

    cout << ">> Total number of entries: " << globChain->GetEntriesFast() << endl;
    fList.close();

    if(Nfiles == 0){
	delete globChain;
	return NULL;
    }

    return globChain;
}
